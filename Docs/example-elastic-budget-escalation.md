# üìà Example: Elastic Budget Escalation

> [!WARNING]
> This example was generated by Claude AI. I haven't reviewed it fully but took a glance at it and it looks mostly right.

This example shows how to use the elastic budget escalation system to automatically increase frame budgets when work is backing up, allowing controlled FPS degradation to prevent work queue buildup.

## Overview

The escalation system dynamically adjusts the frame budget when there's more work than can be processed within the normal budget. Instead of letting work pile up indefinitely, it temporarily increases the budget, causing a controlled FPS drop to catch up on work.

## Console Variable Configuration

```console
gwb.enabled 1
gwb.budget.frame 0.005           // Base budget: 5ms per frame
gwb.escalation.scalar 0.5        // Increase budget by 50% when escalating
gwb.escalation.count 30          // Trigger escalation when 30+ work units are queued
gwb.escalation.duration 0.5      // Scale up over 0.5 seconds
gwb.escalation.decay 0.5         // Scale down over 0.5 seconds when load decreases
```

## How Escalation Works

### Base Configuration
- **Base Budget**: 5ms per frame (200 FPS target)
- **Escalation Trigger**: 30 queued work units
- **Escalation Amount**: +50% (total 7.5ms = ~133 FPS)
- **Scaling**: Gradually increases/decreases over 0.5 seconds

### Escalation Scenarios

#### Scenario 1: Normal Load
```
Queued Work: 10 units
Frame Budget: 5ms (base)
FPS Impact: None
Behavior: Normal processing
```

#### Scenario 2: Heavy Load - Escalation Triggered
```
Queued Work: 35 units (exceeds threshold of 30)
Frame Budget: 5ms ‚Üí gradually increases to 7.5ms
FPS Impact: 200 FPS ‚Üí gradually drops to ~133 FPS
Behavior: Processes more work per frame to catch up
```

#### Scenario 3: Load Decreases - Escalation Decay
```
Queued Work: 35 ‚Üí 20 ‚Üí 10 units
Frame Budget: 7.5ms ‚Üí gradually decreases back to 5ms
FPS Impact: 133 FPS ‚Üí gradually returns to 200 FPS
Behavior: Smooth transition back to normal performance
```

## C++ Implementation

### Registering the Escalation Modifier

The escalation modifier is typically registered automatically.

## Real-World Use Cases

### Scenario 1: Mass Actor Spawning

```cpp
void ASpawnerActor::SpawnWaveOfEnemies()
{
    // Spawn 100 enemies - will likely trigger escalation
    for (int32 i = 0; i < 100; ++i)
    {
        UGWBManager::ScheduleWork(
            this,
            "Spawning",
            FGWBWorkOptions::EmptyOptions
        ).OnHandleWork([this, i]() {
            SpawnSingleEnemy(EnemySpawnLocations[i]);
        });
    }
    
    // Escalation will automatically:
    // 1. Detect 100 queued work units (> 30 threshold)
    // 2. Gradually increase budget from 5ms to 7.5ms
    // 3. Process more enemies per frame
    // 4. Gradually return to normal budget when queue clears
}
```

### Scenario 2: Level Cleanup

```cpp
void ALevelManager::CleanupCurrentLevel()
{
    // Destroy many objects - escalation prevents long cleanup delays
    for (AActor* Actor : ActorsToDestroy)
    {
        UGWBManager::ScheduleWork(
            this,
            "Cleanup",
            FGWBWorkOptions::EmptyOptions
        ).OnHandleWork([Actor]() {
            if (IsValid(Actor))
            {
                Actor->Destroy();
            }
        });
    }
    
    // Without escalation: Cleanup might take many seconds
    // With escalation: Temporary FPS drop, but faster cleanup
}
```

## INI Configuration

You can also configure escalation in your project INI:

```ini
[/Script/GWBRuntime.GWBManager]
; Global escalation settings
gwb.escalation.scalar=0.75     ; 75% budget increase when escalating
gwb.escalation.count=25        ; Trigger at 25 queued items
gwb.escalation.duration=0.3    ; Faster scaling (0.3 seconds)
gwb.escalation.decay=1.0       ; Slower decay (1.0 second)

; Work groups can have different escalation behaviors
+WorkGroupDefinitions=(Id="Combat",Priority=75,MaxFrameBudget=0.008,MaxWorkUnitsPerFrame=15)
+WorkGroupDefinitions=(Id="Cleanup",Priority=25,MaxFrameBudget=0.010,MaxWorkUnitsPerFrame=20)
```

## Monitoring and Debugging

### Performance Stats

```cpp
// Monitor escalation through stats
STAT_DoWorkForFrame              // Shows actual time spent (will increase during escalation)
STAT_GameWorkBalancer_WorkCount  // Shows work units processed

// Console commands for tuning
stat GameWorkBalancer
gwb.escalation.scalar 0.25      // Reduce escalation amount
gwb.escalation.count 50         // Increase escalation threshold
```

## Best Practices

1. **Tune Thresholds**: Adjust `gwb.escalation.count` based on your game's typical work loads

2. **Monitor Player Experience**: Use telemetry to understand how often escalation occurs

3. **Balance Escalation Amount**: Too high causes noticeable FPS drops, too low doesn't help

4. **Consider Platform Differences**: Mobile devices may need different escalation settings

5. **Use Temporary Escalation**: Escalation should be temporary - address root causes of work buildup

6. **Test Edge Cases**: Verify behavior during loading screens, level transitions, etc.

## When to Use Escalation

‚úÖ **Good for:**
- Occasional spikes in work load
- Mass operations (spawning, destruction)
- Preventing indefinite work queue buildup
- Maintaining responsiveness during heavy processing

‚ùå **Avoid for:**
- Consistently high work loads (fix the underlying performance issue)
- Performance-critical applications where FPS drops are unacceptable
- When work can be easily spread over longer time periods

The elastic budget escalation system provides a safety valve for your performance budget, allowing temporary controlled FPS reduction to prevent work from backing up indefinitely while maintaining overall game responsiveness.