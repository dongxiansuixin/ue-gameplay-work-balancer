# ⏱️ Example: Time and Count Budget Limits

> [!WARNING]
> This example was generated by Claude AI. I haven't reviewed it fully but took a glance at it and it looks mostly right.

This example shows how to use both time budgets (5ms) and count budgets (max 10 jobs) per frame to control work execution.

## Console Variable Configuration

Set up the system to use both time and count limits:

```console
gwb.enabled 1
gwb.budget.frame 0.005     // 5ms time budget per frame
gwb.budget.count 10        // Maximum 10 work units per frame
```

## INI Configuration

You can also configure this in your project INI:

```ini
[/Script/GWBRuntime.GWBManager]
; Work group with dual budget constraints
+WorkGroupDefinitions=(Id="DualConstraint",Priority=50,MaxFrameBudget=0.005,MaxWorkUnitsPerFrame=10)
```

## C++ Implementation

```cpp
void AMyGameActor::ProcessLargeDataSet()
{
    // Schedule work for a large number of items
    // The system will process max 10 items OR 5ms worth of work per frame
    for (int32 i = 0; i < LargeDataArray.Num(); ++i)
    {
        const int32 Index = i; // Capture by value for lambda
        
        UGWBManager::ScheduleWork(
            this,
            "DualConstraint", // Work group with both time and count limits
            FGWBWorkOptions::EmptyOptions
        ).OnHandleWork([this, Index]() {
            // Each work unit processes one data item
            ProcessSingleDataItem(LargeDataArray[Index]);
        });
    }
}

void AMyGameActor::ProcessSingleDataItem(const FMyDataItem& Item)
{
    // This function should ideally take less than 0.5ms (5ms budget / 10 items)
    // but the system will enforce both constraints regardless
    
    // Example processing that might take variable time
    Item.DoExpensiveCalculation();
    Item.UpdateVisualRepresentation();
    Item.SaveToDatabase();
}
```

## Alternative: Using Work Options

You can also set budgets per work unit using `FGWBWorkOptions`:

```cpp
void AMyGameActor::ProcessWithCustomBudget()
{
    FGWBWorkOptions Options;
    Options.Priority = 75; // Higher priority within the group
    
    for (auto& ImportantItem : ImportantItems)
    {
        UGWBManager::ScheduleWork(
            this,
            "DualConstraint",
            Options
        ).OnHandleWork([ImportantItem]() {
            ImportantItem->DoImportantWork();
        });
    }
}
```

## How the Dual Budget System Works

The system enforces **both** constraints simultaneously:

1. **Time Budget**: Tracks cumulative execution time per frame
   - Stops processing when 5ms is exceeded
   - Resets each frame
   
2. **Count Budget**: Tracks number of work units executed per frame  
   - Stops processing when 10 work units are executed
   - Resets each frame

3. **First Limit Wins**: Whichever limit is hit first stops work processing for that frame

## Example Scenarios

### Scenario 1: Time Limit Hit First
- 7 work units processed in 5.1ms
- **Result**: Processing stops at 7 work units (time budget exceeded)
- Remaining 3 work units deferred to next frame

### Scenario 2: Count Limit Hit First  
- 10 work units processed in 3.2ms
- **Result**: Processing stops at 10 work units (count budget exceeded)
- Remaining work deferred despite available time budget

### Scenario 3: Neither Limit Hit
- 8 work units processed in 4.1ms  
- **Result**: All queued work completed within both budgets
- Frame has capacity for more work

## Monitoring Performance

Use these stats to monitor dual budget performance:

```cpp
// Check current frame statistics
STAT_DoWorkForFrame              // Total time spent this frame
STAT_GameWorkBalancer_WorkCount  // Total work units processed

// Console commands for debugging
stat GameWorkBalancer           // Show all GWB stats
gwb.budget.frame -1            // Disable time budget (count only)
gwb.budget.count -1            // Disable count budget (time only)
```

## Best Practices

1. **Balance Your Budgets**: Ensure time budget makes sense for your count budget
   - If each work unit takes ~0.5ms on average, 10 units need ~5ms budget
   
2. **Profile Your Work Units**: Measure actual execution time to set realistic budgets
   
3. **Consider Platform Differences**: Slower platforms may need higher time budgets
   
4. **Monitor in Development**: Use stats to verify your budgets are appropriate

This dual-budget approach is perfect for scenarios where you want to limit both the total time spent and the number of operations performed per frame, giving you fine-grained control over performance.